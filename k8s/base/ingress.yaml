apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ethos-ingress
  namespace: ethos-go
  labels:
    app.kubernetes.io/name: ethos
    app.kubernetes.io/component: ingress
    app.kubernetes.io/part-of: ethos-go
  annotations:
    # NGINX Ingress Controller annotations
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"

    # Enable gzip compression
    nginx.ingress.kubernetes.io/enable-compression: "true"

    # Rate limiting
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/limit-connections: "20"
    nginx.ingress.kubernetes.io/limit-req-status-code: "429"

    # CORS - can be more restrictive in production
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-origin: "https://ethos.example.com"  # Change to your domain
    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"

    # Security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      # Security headers
      more_set_headers "X-Frame-Options: DENY";
      more_set_headers "X-Content-Type-Options: nosniff";
      more_set_headers "X-XSS-Protection: 1; mode=block";
      more_set_headers "Referrer-Policy: strict-origin-when-cross-origin";
      more_set_headers "Permissions-Policy: camera=(), microphone=(), geolocation=()";

      # Cache static assets
      if ($uri ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$) {
        more_set_headers "Cache-Control: public, max-age=31536000, immutable";
      }

      # Don't cache HTML/API responses
      if ($uri ~* ^/(api|health|version|metrics)/) {
        more_set_headers "Cache-Control: no-cache, no-store, must-revalidate";
      }

    # Cert-manager for automatic TLS
    cert-manager.io/cluster-issuer: "letsencrypt-prod"

spec:
  ingressClassName: nginx  # Change to your ingress class

  tls:
    - hosts:
        - ethos.example.com  # Change to your domain
      secretName: ethos-tls

  rules:
    # Main domain serves both frontend and API
    - host: ethos.example.com  # Change to your domain
      http:
        paths:
          # All routes go to the same service (Go app serves everything)
          - path: /
            pathType: Prefix
            backend:
              service:
                name: ethos-app
                port:
                  number: 80

---
# Optional: Separate API subdomain (if you want api.ethos.example.com)
# Uncomment if you want a dedicated API subdomain
# apiVersion: networking.k8s.io/v1
# kind: Ingress
# metadata:
#   name: ethos-api-ingress
#   namespace: ethos-go
#   labels:
#     app.kubernetes.io/name: ethos
#     app.kubernetes.io/component: ingress-api
#   annotations:
#     nginx.ingress.kubernetes.io/ssl-redirect: "true"
#     nginx.ingress.kubernetes.io/proxy-body-size: "10m"
#     cert-manager.io/cluster-issuer: "letsencrypt-prod"
# spec:
#   ingressClassName: nginx
#   tls:
#     - hosts:
#         - api.ethos.example.com
#       secretName: ethos-api-tls
#   rules:
#     - host: api.ethos.example.com
#       http:
#         paths:
#           - path: /api
#             pathType: Prefix
#             backend:
#               service:
#                 name: ethos-app
#                 port:
#                   number: 80
