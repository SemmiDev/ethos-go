// Package habits provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package habits

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ListHabitsParamsSortBy.
const (
	ListHabitsParamsSortByCreatedAt ListHabitsParamsSortBy = "created_at"
	ListHabitsParamsSortByIsActive  ListHabitsParamsSortBy = "is_active"
	ListHabitsParamsSortByName      ListHabitsParamsSortBy = "name"
	ListHabitsParamsSortByUpdatedAt ListHabitsParamsSortBy = "updated_at"
)

// Defines values for ListHabitsParamsSortDirection.
const (
	ListHabitsParamsSortDirectionAsc  ListHabitsParamsSortDirection = "asc"
	ListHabitsParamsSortDirectionDesc ListHabitsParamsSortDirection = "desc"
)

// Defines values for GetHabitLogsParamsSortBy.
const (
	GetHabitLogsParamsSortByCount     GetHabitLogsParamsSortBy = "count"
	GetHabitLogsParamsSortByCreatedAt GetHabitLogsParamsSortBy = "created_at"
	GetHabitLogsParamsSortByLogDate   GetHabitLogsParamsSortBy = "log_date"
)

// Defines values for GetHabitLogsParamsSortDirection.
const (
	GetHabitLogsParamsSortDirectionAsc  GetHabitLogsParamsSortDirection = "asc"
	GetHabitLogsParamsSortDirectionDesc GetHabitLogsParamsSortDirection = "desc"
)

// CreateHabitRequest defines model for CreateHabitRequest.
type CreateHabitRequest struct {
	Description *string `json:"description,omitempty"`
	Frequency   *string `json:"frequency,omitempty"`
	Name        string  `json:"name"`

	// ReminderTime Daily reminder time in HH:MM format
	ReminderTime *string `json:"reminder_time,omitempty"`
	TargetCount  *int    `json:"target_count,omitempty"`
}

// DailyAnalytics defines model for DailyAnalytics.
type DailyAnalytics struct {
	// CompletionPercentage Completion percentage for this day (0-100)
	CompletionPercentage *int                `json:"completion_percentage,omitempty"`
	Date                 *openapi_types.Date `json:"date,omitempty"`

	// DayName Day of week name (Mon, Tue, etc.)
	DayName *string `json:"day_name,omitempty"`

	// LogsCount Number of habit logs on this day
	LogsCount *int `json:"logs_count,omitempty"`
}

// Dashboard defines model for Dashboard.
type Dashboard struct {
	ActiveHabitsCount *int `json:"active_habits_count,omitempty"`
	CurrentStreak     *int `json:"current_streak,omitempty"`
	LongestStreak     *int `json:"longest_streak,omitempty"`

	// TotalLogs Total habit logs all time
	TotalLogs      *int `json:"total_logs,omitempty"`
	TotalLogsToday *int `json:"total_logs_today,omitempty"`

	// WeeklyCompletion Weekly completion percentage (0-100)
	WeeklyCompletion *int `json:"weekly_completion,omitempty"`
}

// DashboardWrapper defines model for DashboardWrapper.
type DashboardWrapper struct {
	Data    *Dashboard `json:"data,omitempty"`
	Message *string    `json:"message,omitempty"`
	Success *bool      `json:"success,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error *struct {
		Code    *string                 `json:"code,omitempty"`
		Details *map[string]interface{} `json:"details,omitempty"`
	} `json:"error,omitempty"`
	Message *string `json:"message,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// Habit defines model for Habit.
type Habit struct {
	CreatedAt   time.Time          `json:"created_at"`
	Description *string            `json:"description,omitempty"`
	Frequency   *string            `json:"frequency,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	IsActive    *bool              `json:"is_active,omitempty"`
	Name        string             `json:"name"`

	// ReminderTime Daily reminder time in HH:MM format (e.g., "08:00")
	ReminderTime *string    `json:"reminder_time,omitempty"`
	TargetCount  *int       `json:"target_count,omitempty"`
	UpdatedAt    *time.Time `json:"updated_at,omitempty"`
}

// HabitListWrapper Deprecated. Use PaginatedHabitListWrapper instead.
type HabitListWrapper struct {
	Data    *[]Habit `json:"data,omitempty"`
	Message *string  `json:"message,omitempty"`
	Success *bool    `json:"success,omitempty"`
}

// HabitLog defines model for HabitLog.
type HabitLog struct {
	Count     *int                `json:"count,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	HabitId   *openapi_types.UUID `json:"habit_id,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	LogDate   *openapi_types.Date `json:"log_date,omitempty"`
	Note      *string             `json:"note,omitempty"`
}

// HabitLogCreatedWrapper defines model for HabitLogCreatedWrapper.
type HabitLogCreatedWrapper struct {
	Data *struct {
		LogId *openapi_types.UUID `json:"log_id,omitempty"`
	} `json:"data,omitempty"`
	Message *string `json:"message,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// HabitLogsWrapper Deprecated. Use PaginatedHabitLogsWrapper instead.
type HabitLogsWrapper struct {
	Data    *[]HabitLog `json:"data,omitempty"`
	Message *string     `json:"message,omitempty"`
	Success *bool       `json:"success,omitempty"`
}

// HabitStats defines model for HabitStats.
type HabitStats struct {
	CurrentStreak *int `json:"current_streak,omitempty"`
	LongestStreak *int `json:"longest_streak,omitempty"`
	TotalLogs     *int `json:"total_logs,omitempty"`
}

// HabitStatsWrapper defines model for HabitStatsWrapper.
type HabitStatsWrapper struct {
	Data    *HabitStats `json:"data,omitempty"`
	Message *string     `json:"message,omitempty"`
	Success *bool       `json:"success,omitempty"`
}

// HabitWrapper defines model for HabitWrapper.
type HabitWrapper struct {
	Data    *Habit  `json:"data,omitempty"`
	Message *string `json:"message,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// LogHabitRequest defines model for LogHabitRequest.
type LogHabitRequest struct {
	Count   int                `json:"count"`
	LogDate openapi_types.Date `json:"log_date"`
	Note    *string            `json:"note,omitempty"`
}

// PaginatedHabitListWrapper defines model for PaginatedHabitListWrapper.
type PaginatedHabitListWrapper struct {
	Data    *[]Habit `json:"data,omitempty"`
	Message *string  `json:"message,omitempty"`
	Meta    *struct {
		// Pagination Pagination metadata for list responses
		Pagination *Pagination `json:"pagination,omitempty"`
	} `json:"meta,omitempty"`
	Success *bool `json:"success,omitempty"`
}

// PaginatedHabitLogsWrapper defines model for PaginatedHabitLogsWrapper.
type PaginatedHabitLogsWrapper struct {
	Data    *[]HabitLog `json:"data,omitempty"`
	Message *string     `json:"message,omitempty"`
	Meta    *struct {
		// Pagination Pagination metadata for list responses
		Pagination *Pagination `json:"pagination,omitempty"`
	} `json:"meta,omitempty"`
	Success *bool `json:"success,omitempty"`
}

// Pagination Pagination metadata for list responses
type Pagination struct {
	// CurrentPage Current page number (1-indexed)
	CurrentPage *int `json:"current_page,omitempty"`

	// From Index of the first item in the current page (1-indexed)
	From *int `json:"from,omitempty"`

	// HasNextPage Whether there is a next page
	HasNextPage *bool `json:"has_next_page,omitempty"`

	// HasPreviousPage Whether there is a previous page
	HasPreviousPage *bool `json:"has_previous_page,omitempty"`

	// LastPage Last page number
	LastPage *int `json:"last_page,omitempty"`

	// PerPage Number of items per page
	PerPage *int `json:"per_page,omitempty"`

	// To Index of the last item in the current page
	To *int `json:"to,omitempty"`

	// TotalData Total number of items across all pages
	TotalData *int `json:"total_data,omitempty"`

	// TotalDataInCurrentPage Number of items in the current page
	TotalDataInCurrentPage *int `json:"total_data_in_current_page,omitempty"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// UpdateHabitLogRequest defines model for UpdateHabitLogRequest.
type UpdateHabitLogRequest struct {
	Count *int `json:"count,omitempty"`

	// LogDate Log date in ISO 8601 format
	LogDate *time.Time `json:"log_date,omitempty"`
	Note    *string    `json:"note,omitempty"`
}

// UpdateHabitRequest defines model for UpdateHabitRequest.
type UpdateHabitRequest struct {
	Description *string `json:"description,omitempty"`
	Frequency   *string `json:"frequency,omitempty"`
	Name        *string `json:"name,omitempty"`

	// ReminderTime Daily reminder time in HH:MM format
	ReminderTime *string `json:"reminder_time,omitempty"`
	TargetCount  *int    `json:"target_count,omitempty"`
}

// WeeklyAnalytics defines model for WeeklyAnalytics.
type WeeklyAnalytics struct {
	// AverageCompletion Average completion percentage for the week
	AverageCompletion *int              `json:"average_completion,omitempty"`
	Days              *[]DailyAnalytics `json:"days,omitempty"`
}

// WeeklyAnalyticsWrapper defines model for WeeklyAnalyticsWrapper.
type WeeklyAnalyticsWrapper struct {
	Data    *WeeklyAnalytics `json:"data,omitempty"`
	Message *string          `json:"message,omitempty"`
	Success *bool            `json:"success,omitempty"`
}

// ListHabitsParams defines parameters for ListHabits.
type ListHabitsParams struct {
	// Page Page number (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Keyword Search keyword (searches in name and description)
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// Active Filter by active status
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Inactive Filter by inactive status
	Inactive *bool `form:"inactive,omitempty" json:"inactive,omitempty"`

	// StartDate Filter habits created on or after this date
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate Filter habits created on or before this date
	EndDate *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`

	// SortBy Column to sort by
	SortBy *ListHabitsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection Sort direction
	SortDirection *ListHabitsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`
}

// ListHabitsParamsSortBy defines parameters for ListHabits.
type ListHabitsParamsSortBy string

// ListHabitsParamsSortDirection defines parameters for ListHabits.
type ListHabitsParamsSortDirection string

// GetHabitLogsParams defines parameters for GetHabitLogs.
type GetHabitLogsParams struct {
	// Page Page number (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// StartDate Filter logs on or after this date
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate Filter logs on or before this date
	EndDate *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`

	// Keyword Search keyword (searches in note)
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// SortBy Column to sort by
	SortBy *GetHabitLogsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortDirection Sort direction
	SortDirection *GetHabitLogsParamsSortDirection `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`
}

// GetHabitLogsParamsSortBy defines parameters for GetHabitLogs.
type GetHabitLogsParamsSortBy string

// GetHabitLogsParamsSortDirection defines parameters for GetHabitLogs.
type GetHabitLogsParamsSortDirection string

// UpdateHabitLogJSONRequestBody defines body for UpdateHabitLog for application/json ContentType.
type UpdateHabitLogJSONRequestBody = UpdateHabitLogRequest

// CreateHabitJSONRequestBody defines body for CreateHabit for application/json ContentType.
type CreateHabitJSONRequestBody = CreateHabitRequest

// UpdateHabitJSONRequestBody defines body for UpdateHabit for application/json ContentType.
type UpdateHabitJSONRequestBody = UpdateHabitRequest

// LogHabitJSONRequestBody defines body for LogHabit for application/json ContentType.
type LogHabitJSONRequestBody = LogHabitRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get weekly analytics data
	// (GET /analytics/weekly)
	GetWeeklyAnalytics(w http.ResponseWriter, r *http.Request)
	// Get user dashboard
	// (GET /dashboard)
	GetDashboard(w http.ResponseWriter, r *http.Request)
	// Delete a habit log
	// (DELETE /habit-logs/{logId})
	DeleteHabitLog(w http.ResponseWriter, r *http.Request, logId openapi_types.UUID)
	// Update a habit log
	// (PUT /habit-logs/{logId})
	UpdateHabitLog(w http.ResponseWriter, r *http.Request, logId openapi_types.UUID)
	// List all habits
	// (GET /habits)
	ListHabits(w http.ResponseWriter, r *http.Request, params ListHabitsParams)
	// Create a new habit
	// (POST /habits)
	CreateHabit(w http.ResponseWriter, r *http.Request)
	// Delete a habit
	// (DELETE /habits/{habitId})
	DeleteHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID)
	// Get a habit by ID
	// (GET /habits/{habitId})
	GetHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID)
	// Update a habit
	// (PUT /habits/{habitId})
	UpdateHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID)
	// Activate a habit
	// (POST /habits/{habitId}/activate)
	ActivateHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID)
	// Deactivate a habit
	// (POST /habits/{habitId}/deactivate)
	DeactivateHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID)
	// Get habit logs
	// (GET /habits/{habitId}/logs)
	GetHabitLogs(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID, params GetHabitLogsParams)
	// Log a habit
	// (POST /habits/{habitId}/logs)
	LogHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID)
	// Get habit statistics
	// (GET /habits/{habitId}/stats)
	GetHabitStats(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get weekly analytics data
// (GET /analytics/weekly)
func (_ Unimplemented) GetWeeklyAnalytics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user dashboard
// (GET /dashboard)
func (_ Unimplemented) GetDashboard(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a habit log
// (DELETE /habit-logs/{logId})
func (_ Unimplemented) DeleteHabitLog(w http.ResponseWriter, r *http.Request, logId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a habit log
// (PUT /habit-logs/{logId})
func (_ Unimplemented) UpdateHabitLog(w http.ResponseWriter, r *http.Request, logId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all habits
// (GET /habits)
func (_ Unimplemented) ListHabits(w http.ResponseWriter, r *http.Request, params ListHabitsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new habit
// (POST /habits)
func (_ Unimplemented) CreateHabit(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a habit
// (DELETE /habits/{habitId})
func (_ Unimplemented) DeleteHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a habit by ID
// (GET /habits/{habitId})
func (_ Unimplemented) GetHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a habit
// (PUT /habits/{habitId})
func (_ Unimplemented) UpdateHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Activate a habit
// (POST /habits/{habitId}/activate)
func (_ Unimplemented) ActivateHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Deactivate a habit
// (POST /habits/{habitId}/deactivate)
func (_ Unimplemented) DeactivateHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get habit logs
// (GET /habits/{habitId}/logs)
func (_ Unimplemented) GetHabitLogs(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID, params GetHabitLogsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Log a habit
// (POST /habits/{habitId}/logs)
func (_ Unimplemented) LogHabit(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get habit statistics
// (GET /habits/{habitId}/stats)
func (_ Unimplemented) GetHabitStats(w http.ResponseWriter, r *http.Request, habitId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetWeeklyAnalytics operation middleware
func (siw *ServerInterfaceWrapper) GetWeeklyAnalytics(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWeeklyAnalytics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDashboard operation middleware
func (siw *ServerInterfaceWrapper) GetDashboard(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDashboard(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteHabitLog operation middleware
func (siw *ServerInterfaceWrapper) DeleteHabitLog(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "logId" -------------
	var logId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "logId", chi.URLParam(r, "logId"), &logId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "logId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteHabitLog(w, r, logId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateHabitLog operation middleware
func (siw *ServerInterfaceWrapper) UpdateHabitLog(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "logId" -------------
	var logId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "logId", chi.URLParam(r, "logId"), &logId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "logId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateHabitLog(w, r, logId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListHabits operation middleware
func (siw *ServerInterfaceWrapper) ListHabits(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListHabitsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "per_page", Err: err})
		return
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", r.URL.Query(), &params.Keyword)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyword", Err: err})
		return
	}

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", r.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "active", Err: err})
		return
	}

	// ------------- Optional query parameter "inactive" -------------

	err = runtime.BindQueryParameter("form", true, false, "inactive", r.URL.Query(), &params.Inactive)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inactive", Err: err})
		return
	}

	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_date", Err: err})
		return
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_date", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", r.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_by", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_direction", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListHabits(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateHabit operation middleware
func (siw *ServerInterfaceWrapper) CreateHabit(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateHabit(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteHabit operation middleware
func (siw *ServerInterfaceWrapper) DeleteHabit(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteHabit(w, r, habitId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHabit operation middleware
func (siw *ServerInterfaceWrapper) GetHabit(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHabit(w, r, habitId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateHabit operation middleware
func (siw *ServerInterfaceWrapper) UpdateHabit(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateHabit(w, r, habitId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ActivateHabit operation middleware
func (siw *ServerInterfaceWrapper) ActivateHabit(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ActivateHabit(w, r, habitId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeactivateHabit operation middleware
func (siw *ServerInterfaceWrapper) DeactivateHabit(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeactivateHabit(w, r, habitId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHabitLogs operation middleware
func (siw *ServerInterfaceWrapper) GetHabitLogs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetHabitLogsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", r.URL.Query(), &params.PerPage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "per_page", Err: err})
		return
	}

	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_date", Err: err})
		return
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_date", Err: err})
		return
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", r.URL.Query(), &params.Keyword)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyword", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", r.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_by", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_direction", r.URL.Query(), &params.SortDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_direction", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHabitLogs(w, r, habitId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LogHabit operation middleware
func (siw *ServerInterfaceWrapper) LogHabit(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogHabit(w, r, habitId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHabitStats operation middleware
func (siw *ServerInterfaceWrapper) GetHabitStats(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "habitId" -------------
	var habitId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "habitId", chi.URLParam(r, "habitId"), &habitId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "habitId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHabitStats(w, r, habitId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/analytics/weekly", wrapper.GetWeeklyAnalytics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dashboard", wrapper.GetDashboard)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/habit-logs/{logId}", wrapper.DeleteHabitLog)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/habit-logs/{logId}", wrapper.UpdateHabitLog)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/habits", wrapper.ListHabits)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/habits", wrapper.CreateHabit)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/habits/{habitId}", wrapper.DeleteHabit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/habits/{habitId}", wrapper.GetHabit)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/habits/{habitId}", wrapper.UpdateHabit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/habits/{habitId}/activate", wrapper.ActivateHabit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/habits/{habitId}/deactivate", wrapper.DeactivateHabit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/habits/{habitId}/logs", wrapper.GetHabitLogs)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/habits/{habitId}/logs", wrapper.LogHabit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/habits/{habitId}/stats", wrapper.GetHabitStats)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xb3W/bOBL/VwjePSSBYzu7e3cLv+U2u9cAyW3QtCiKJrBpaWxzK5EqSSUVgvzvhyEl",
	"64vyR2Kn6e49NZZGnO/hzI/sAw1knEgBwmg6eqA6WEDM7J+/KGAG3rApN2/hSwra4NNEyQSU4WBpQtCB",
	"4onhUuBPkyVAR1QbxcWcPvboTOGXIsjwLXxlcRIhQch4lNFem16wGLwLKYi5CEGNDXcUNc70DBckBRFB",
	"IsIFefNmdHlJZlLFzNBeRYDhz6Ph0CeAYWoOZhzIVJiazCdLYi4MzEHRRyvWl5QrCOnok5P9dkkmp39A",
	"YHBNK9ypYFFmeKDbRkQPRICajBNQAQjD5h4df1mSkZIMlSNmwTUJWUYOhscnw+EhbcvaoyEzdtHcGiP3",
	"wGOCkGXjwg9NK2dEzsg9wGeCFOTgUooeeZdCj4AJ+oe+5SI516U96wv+N42noHDNBYYZQVoixVIh6jW6",
	"x8B6MZVMhW3bssDwOxjb5StitM0TpEqBMGNtFLDPfppIijno1TRGGhaNUZG2uu/wXVVVFkU2Vr0OK1ca",
	"G4nG8PJDZ0TZuIyhNtsPloQE3vjpDpmVlv6gWJKA8lQEZhj++3cFMzqifxuU9WWQF5dB6a/HHo1B6zze",
	"W7Gj0yAArWuJaFQKS8mmUkbAhF/YX5WS6i3oRAoNbUkBX/uyMfQLE4JhPNKVdwUrH/Nt1ZqxSG+oly3J",
	"HsFtvQ7HzLTS/LgeZFWdtqjfrbc8rHFKUx76mHA9dmlYWWSp4F5rPjmA/rzfIzeu4N/Qw6ftAu20S5Nw",
	"S2M3dgtrKqt6r+q52y5/X3BtKkkXQqIgwK+KjGgYZ/m+T95rIFdszgX+bC5GuNAGWNinvY5M5gZivS6l",
	"XUyW0cqUYtl+09tpIue+FO4u809IEluwx5sG+2ZkkZyPN96RhTQ+A64yimve1pfp+lOUaiMFdlHxtve0",
	"3l0ClIvtMgEwGl8+B64NM762ci8dzSZdQinVs9qEinL7N+LzJd2vkBdyvnoUW1H0dlRsqtvXcslezti3",
	"cXVuOt1W3t9mE4Ov4iVOxLz/WcX0qqT0Ouh57u0sT7sw1RPK0ndhLe+0U74jqARayw7JEdeGqHwa0K1i",
	"X1TLxD97u7cE3xLhptaDk2PsPL9C6B+4Z0rG7ZXO8ROceM0CyIwrbQg6EjtXfBJUGa3jsGB6LOBrl9Af",
	"FmAW2BkvQAHhmjCC1HZt2vN04rheouCOy1RvvmbxRfe6EdNdMl4wXbOqV88EVMfnJYBgswEH24YYtY1s",
	"jTtQzk5vrJjRi4z0TfuiISELlNRu8sdV9Zplx1yMV4dm0wSbie7LqmuXk90Tc6VglEPU7wkol255Ts/S",
	"yLevPC/j39t5q6hmz90EGzEo5wTfoOnOr38nP/9zeFKChpvNCFu06BVVdoOrvn4UdZPocyjVCpiU3YFi",
	"c1gJdZ06mg6sy2GlYAHMDow00xtvrQ1Yt7XBbqDks5rOpsH22H7iIy5mnvp5enVuzRozgfvu3KGbtqpx",
	"Y4PEBromp1fntEfvQGn34Ul/2B+iXDIBwRJOR/TH/rD/I27MzCysnANWKDdwMCc+nIMHSH4LJlVC59hq",
	"xfvL7X9Z3/9F0Mv9G/ErCxYWNeciiNIQtKURdUhaF4tBSJgI/YHVvxHUKuIK4XlIR/Q/YJoOwvwr2o/R",
	"A/1hOHQlSxhwacKSJOKBXWPwh3bx7by9ZSwUcWUd5wWDl5a1FrI+12kcM5U52cl9J90grMLtuTtaypcY",
	"7x7VbsHRHoXfa1BkKXKXummNyulpA+AYB9/BQyTn5+GjCzyMhrbOZ/b5st/GMFYsBgNK09GnB8pRGAzt",
	"AvcbUbsorQ5WLiFL5dfBMLd7NG6zHfDY9k1xlEGcVcKGZZ1NCCvPPGw7l3pCpr7Bv6T57Bb8bxlmO7Oc",
	"v1l5rM/QKOvja3FfDmc33Of0qLtvmRi6sxhjPjGSFBOtm7zKgnrPzcLWUQULEJrf4RwUGUCfEGkXwfJ8",
	"I46Oylnu6GhkYbwJ9rMTW4onxVgwIV9SUBkpIyb//Ldi2aOj0Y04JhN3DDEZTLjI/yTHOXMyzYg2zKTa",
	"Un6G7F6qcEKkIpMvSKaBqWCB/ZA9+kQJKmrbj7RhytgmczKYgAjdnzUWFn/ONyYgBy5AR+Tjx48fjy8v",
	"j8/ODp3o11IZJ7hTW0tlxtNsQg6Qe4+UOHaPlGcRh84wljjkCgJkNSEHTAc9K+2hb6u64Nq8KbbtRtq1",
	"ZuuO8demp3VDmZ/56FGGawgzlkbGHqbHXPA4jTsO1reY87yci4HRy/2HYY/G7GvOfjjcVphrFwl5iJAD",
	"Fxmgu2Kjyz75AjUhW/NDk/lvy1ByEZwHbQeL/NzNw6HS7XWzKNJkNZOC6mlsijbLBTSRAlOOzQws7zWY",
	"LjeX+Ua9Vd8PcW4nyRRmUsFaUYpsf54gv8gojQUxkmAKk2nWpbirBjVmIDCAP3nOFGunldXj2NsNRMJC",
	"RJa1ZJU8VSJP1lGmA5weczHdL+TlE2OffU03Ku3ZIk879zHsZP6xQ7HqtxU8opwLA0qwiFyDugNF7AeN",
	"HRu1sdhSKWMitafdqlzuovtpgjzXxzbqgE52JkHtXMdj0HcLWCb7ojhS+OllXXrHIh4SLrAnrrvS2c9i",
	"tveFeGXzNXiw/24+k2zUUedrfv8jST6OVCDJKHPe/enlvOtEEdKQmUzF6tkIhesapf88/tskIyuZ+Gp8",
	"5SYaNwVNM3J+tskY+7Ie2+sU+41G2E3CJW9tXmXY1Odnf/ke2F4sP5fw79WnOcVfsI4XxmlatjDJGtuG",
	"sN66Z0uav+Q+2WXh0ixrbFxcDNoeCnJ3oC0c9FIA0DqExko0zRw6o5iYd2E06yAiaUCvQ3KKE8k6mmMP",
	"zZ4G5BS9wgW65KXiuPd/kGgFplD8j4ZvhWlU+L8okrESI5MGdoqJ7QI2qV5oq0InzdttL4GUWFTkFUIl",
	"lVtpnh3lakWV9/TT1ZddKEVx6fF7b6Wblze/BRDSvhS+6kRo3moILuR8TSegi3vIKwdZd6H3TzPN1q45",
	"d1oUTcO1u6bRkQk1EqSxKJ8zTqoiOqIDlnD6ePv4vwAAAP//9d26JbQ5AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
